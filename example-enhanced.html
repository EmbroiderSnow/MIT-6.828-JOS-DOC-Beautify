<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIT 6.828 Lab 1: PC Bootstrap and GCC Calling Conventions (增强版)</title>
    
    <!-- 原有样式文件 -->
    <link rel="stylesheet" href="Lab 1_ PC Bootstrap and GCC Calling Conventions_files/labs.css" type="text/css">
    
    <!-- 现代化增强样式 -->
    <link rel="stylesheet" href="labs-modern.css" type="text/css">
    
    <!-- 增强功能脚本 -->
    <script src="labs-enhance.js"></script>
</head>
<body>
    <!-- 导航栏 -->
    <div class="jump-hdr">
        <div class="jump-section">
            章节 ▽
            <div class="jump-drop">
                <a href="#Introduction">介绍</a>
                <a href="#Software-Setup">软件设置</a>
                <a href="#Part-1--PC-Bootstrap">第一部分: PC引导</a>
                <a href="#Part-2--The-Boot-Loader">第二部分: 引导加载器</a>
                <a href="#Part-3--The-Kernel">第三部分: 内核</a>
            </div>
        </div>
        <div class="jump-section">
            练习 ▽
            <div class="jump-drop">
                <a href="#Exercise-1">练习 1</a>
                <a href="#Exercise-2">练习 2</a>
                <a href="#Exercise-3">练习 3</a>
                <a href="#Exercise-4">练习 4</a>
            </div>
        </div>
    </div>

    <!-- 主内容 -->
    <main id="main-content">
        <h1>Lab 1: 启动PC</h1>
        <p><b>截止日期：2018年9月13日，星期四</b></p>

        <h2 id="Introduction">介绍</h2>
        <p>
            本实验分为三个部分。第一部分专注于熟悉x86汇编语言、QEMU x86模拟器和PC的上电引导过程。
            第二部分检查我们6.828内核的引导加载器，该加载器位于实验树的<tt>boot</tt>目录中。
            最后，第三部分深入研究我们6.828内核的初始模板，名为JOS，位于<tt>kernel</tt>目录中。
        </p>

        <h3 id="Software-Setup">软件设置</h3>
        <p>
            本课程及后续实验作业所需的文件使用<a href="http://www.git-scm.com/">Git</a>版本控制系统分发。
            要了解更多关于Git的信息，请查看<a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git用户手册</a>。
        </p>

        <!-- 示例：必做练习 -->
        <div class="required">
            <div class="header">练习 1</div>
            <p>
                熟悉汇编语言材料，请阅读
                <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">参考页面</a>
                上的<a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">PC Assembly Language Book</a>。
                您不需要阅读整本书，只需阅读足够的内容来理解我们将要进行的汇编语言练习。
            </p>
        </div>

        <!-- 示例：挑战练习 -->
        <div class="challenge">
            <div class="header">挑战练习</div>
            <p>
                尝试修改链接器脚本，使内核在不同的虚拟地址加载。您需要修改哪些文件？
                您还需要如何调整引导加载器以适应这种变化？
            </p>
        </div>

        <!-- 示例：问题 -->
        <div class="question">
            <div class="header">问题</div>
            <p>
                在哪一点上处理器开始执行32位代码？是什么导致了从16位模式到32位模式的切换？
            </p>
        </div>

        <h2 id="Part-1--PC-Bootstrap">第一部分：PC引导</h2>
        <p>
            第一个练习的目的是向您介绍x86汇编语言和PC引导过程，并让您开始使用QEMU和QEMU/GDB调试。
            您不需要为实验的这一部分编写任何代码，但无论如何您都应该完成它以便理解。
        </p>

        <h3>x86汇编入门</h3>
        <p>
            如果您还不熟悉x86汇编语言，您将在本课程中快速熟悉它！
            <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html">参考页面</a>
            上有几个很好的教程和参考资料。
        </p>

        <!-- 示例代码块：CSS代码 -->
        <h3>现代化CSS样式</h3>
        <p>以下是为代码块设计的现代化CSS样式，支持语法高亮和交互效果：</p>
        <pre><code>/* 现代化的按钮样式 */
.code-copy-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid #6b7280;
    color: var(--text-inverse);
    padding: 0.25rem 0.5rem;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-size: 0.7rem;
    transition: all 0.2s ease;
}

.code-copy-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #9ca3af;
    transform: translateY(-1px);
}

@media (max-width: 768px) {
    .code-copy-btn {
        font-size: 0.6rem;
        padding: 0.2rem 0.4rem;
    }
}
        </code></pre>

        <!-- 示例代码块：汇编代码 -->
        <h3>汇编代码示例</h3>
        <pre><code>.globl _start
_start:
    # 切换到保护模式
    lgdt gdtdesc
    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0
    
    # 跳转到下一条指令，但在32位代码段中
    ljmp $(SEG_KCODE<<3), $protcseg

protcseg:
    # 设置保护模式数据段寄存器
    movw $(SEG_KDATA<<3), %ax    # 我们的数据段选择器
    movw %ax, %ds                # -> DS: 数据段
    movw %ax, %es                # -> ES: 额外段
    movw %ax, %ss                # -> SS: 栈段</code></pre>

        <h3>模拟x86</h3>
        <p>
            我们将使用QEMU模拟器来运行我们将要开发的内核，而不是使用物理PC。
            QEMU是一个现代且相对快速的模拟器。
        </p>

        <!-- 示例代码块：Shell命令 -->
        <pre><code>athena% cd ~/6.828/lab
athena% make
+ as kern/entry.S
+ cc kern/entrypgdir.c
+ cc kern/init.c
+ cc kern/console.c
+ cc kern/monitor.c
+ cc kern/printf.c
+ cc kern/kdebug.c
+ cc lib/printfmt.c
+ cc lib/readline.c
+ cc lib/string.c
+ ld obj/kern/kernel
+ as boot/boot.S
+ cc -Os boot/main.c
+ ld boot/boot
boot block is 380 bytes (max 510)
+ mk obj/kern/kernel.img</code></pre>

        <h2 id="Part-2--The-Boot-Loader">第二部分：引导加载器</h2>
        <p>
            PC的软盘和硬盘被分为512字节的区域，称为扇区。扇区是磁盘的最小传输粒度：
            每个读取或写入操作必须是一个或多个扇区的大小，并且在扇区边界上对齐。
        </p>

        <!-- 示例代码块：C代码 -->
        <pre><code>#include <inc/x86.h>
#include <inc/elf.h>

/**********************************************************************
 * 这个简单的C函数实现了一个简化的ELF加载器。
 * 程序头表告诉我们ELF对象中的每个块应该加载到内存中的什么位置
 * 以及它应该占用多少内存。
 */
static void
readseg(uchar* pa, uint count, uint offset)
{
    uchar* epa;
    
    epa = pa + count;
    
    // 向下舍入到扇区边界
    pa -= offset % SECTSIZE;
    
    // 将偏移量转换为扇区号
    offset = (offset / SECTSIZE) + 1;
    
    // 如果这太慢，我们可以一次读取许多扇区。
    // 我们会写得更复杂，更不容易理解。
    while (pa < epa) {
        readsect(pa, offset);
        pa += SECTSIZE;
        offset++;
    }
}</code></pre>

        <h2 id="Part-3--The-Kernel">第三部分：内核</h2>
        <p>
            现在，您将开始检查最小的6.828内核的一些细节。
            像引导加载器一样，内核开始时有一些汇编语言代码，用于设置一些东西，
            以便C语言代码能够正确执行。
        </p>

        <!-- 示例练习 -->
        <div class="required">
            <div class="header">练习 3</div>
            <p>
                查看<a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">实验工具指南</a>，
                特别是关于GDB命令的部分。即使您熟悉GDB，这里也包含一些对OS工作有用的深奥GDB命令。
            </p>
            <p>
                在地址0x7c00设置断点，这是引导扇区将被加载的位置。继续执行直到该断点。
                跟踪<tt>boot/boot.S</tt>中的代码，使用源代码和反汇编文件<tt>obj/boot/boot.asm</tt>来跟踪您的位置。
            </p>
        </div>

        <!-- 示例：内存布局表格 -->
        <h3>PC物理地址空间</h3>
        <table>
            <thead>
                <tr>
                    <th>起始地址</th>
                    <th>结束地址</th>
                    <th>区域</th>
                    <th>用途</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>0x00000000</code></td>
                    <td><code>0x000A0000</code></td>
                    <td>640KB</td>
                    <td>低内存</td>
                </tr>
                <tr>
                    <td><code>0x000A0000</code></td>
                    <td><code>0x000C0000</code></td>
                    <td>128KB</td>
                    <td>VGA显示</td>
                </tr>
                <tr>
                    <td><code>0x000F0000</code></td>
                    <td><code>0x00100000</code></td>
                    <td>64KB</td>
                    <td>BIOS ROM</td>
                </tr>
            </tbody>
        </table>

        <!-- 更多示例代码 -->
        <h3>格式化输出到控制台</h3>
        <p>
            大多数人认为<tt>printf()</tt>等函数是理所当然的，有时甚至认为它们是C语言的"原语"。
            但在操作系统内核中，我们必须自己实现所有I/O。
        </p>

        <pre><code>// 简单的字符输出函数
static void
cons_putc(int c)
{
    serial_putc(c);
    lpt_putc(c);
    cga_putc(c);
}

void
cputchar(int c)
{
    cons_putc(c);
}

static void
putch(int ch, int *cnt)
{
    cputchar(ch);
    *cnt++;
}</code></pre>

        <div class="question">
            <div class="header">问题</div>
            <p>
                解释<tt>printf.c</tt>和<tt>console.c</tt>之间的接口。
                具体来说，<tt>console.c</tt>导出什么函数？<tt>printf.c</tt>如何使用这个函数？
            </p>
        </div>

        <h3>栈</h3>
        <p>
            在本实验的最后练习中，我们将更详细地探索C语言在x86上使用栈的方式，
            并在此过程中编写一个有用的新内核监视器函数，
            该函数打印栈的回溯：导致当前执行点的嵌套调用指令列表。
        </p>

        <div class="required">
            <div class="header">练习 4</div>
            <p>
                为了熟悉x86上的C调用约定，在<tt>obj/testbacktrace.asm</tt>中找到
                函数<tt>test_backtrace</tt>的地址，在那里设置断点，并检查在内核启动后
                每次调用它时会发生什么。每个递归嵌套级别的<tt>test_backtrace</tt>
                向栈推送多少个32位字，这些字是什么？
            </p>
        </div>

        <!-- 最终的示例代码块 -->
        <pre><code>// 测试栈回溯函数
void
test_backtrace(int x)
{
    cprintf("entering test_backtrace %d\n", x);
    if (x > 0)
        test_backtrace(x-1);
    else
        mon_backtrace(0, 0, 0);
    cprintf("leaving test_backtrace %d\n", x);
}</code></pre>

    </main>

    <!-- 页脚信息 -->
    <footer style="margin-top: 4rem; padding: 2rem 0; border-top: 1px solid var(--border-light); color: var(--text-secondary); font-size: 0.9rem;">
        <p>此页面展示了MIT 6.828实验文档的现代化增强效果。</p>
        <p>包含语法高亮、主题切换、代码复制、响应式设计等功能。</p>
    </footer>

</body>
</html>
